#include "base.h"
#include "client.h"
#include "server.h"

static int server_s = -1;
static pthread_t pthread_sdl, pthread_tcp;
int total_connections = 0;
struct client **clients = NULL;

void exit_server()
{
	void *tret = NULL;

    pthread_join(pthread_sdl, &tret); //等待线程同步
    DEBUG("pthread_exit %d display", (int)tret);
    pthread_join(pthread_tcp, &tret);  //等待线程同步
    DEBUG("pthread_exit %d tcp", (int)tret);
}

int convert_mode(int model)
{
	int i, ret;
	for(i = 0; i < window_size ; i++)
	{
		if(display[i].cli)
		{
			send_done(display[i].cli);
			
		}
	}
}

void close_client(struct client *cli)
{
	close_fd(cli->fd);
}

static int recv_done(struct client *cli)
{   
    if(cli->status == CONTROL)
    {   
        //sem --;
    }
	
	if(cli->status == PLAY)
	{


	}
}

static int send_done(struct client *cli)
{   
    cli->status = READY;
}

static int recv_control(struct client *cli)
{   
    struct request *req = (struct request *)cli->recv_buf;
    if(req->code == 200)
    {   
        cli->status = READY;
        return SUCCESS;
    }   
    else
    {   
        DEBUG("login error code %d msg %s", req->code, req->msg);
        return ERROR;
    }
}

static int send_control(struct client *cli)
{   
    if(cli->status != READY)
        return ERROR;
    cli->status = PLAY;
}

static int recv_play(struct client *cli)
{   
    struct request *req = (struct request *)cli->recv_buf;
	DEBUG("play code %d", req->code);
    if(req->code == 200)
    {   
        cli->status = PLAY;
        //pthread_create();
        return SUCCESS;
    }   
    else
    {   
        DEBUG("play error code %d msg %s", req->code, req->msg);
        return ERROR;
    }
}

static int send_play(struct client *cli)
{
    cli->send_size = sizeof(rtp_format) + 1;
    cli->send_buf = malloc(cli->send_size);
    if(!cli->send_buf)
        return ERROR;

    rtp_format *fmt = (rtp_format *)cli->send_buf;
            
    fmt->width = screen_width;
    fmt->height = screen_width;
    fmt->video_code = H264;
    fmt->video_port = 23000;
    fmt->audio_code = PCM;
    fmt->audio_port = 24000;
    fmt->control_flag = 0;
    fmt->control_port = 0;
    fmt->fps = 12; 
    fmt->bps = 400000;

    set_request_head(cli->send_head, 0, PLAY_MSG, cli->send_size);
    return send_request(cli);
}

static int send_options(struct client *cli)
{
	int ret;

	cli->send_size = sizeof(struct request) + 1;
	cli->send_buf = (unsigned char *)malloc(cli->send_size);

	if(!cli->send_buf)
		return ERROR;

	struct request *req = (struct request *)cli->send_buf;
	
	req->code = 200;
	cli->status = READY;
	set_request_head(cli->send_head, 0, OPTIONS_MSG, cli->send_size);
	ret = send_request(cli);
	
	if(!ret)
	{
		if(ip == cli->ip)		//不是选中的
		{
			send_control(cli);
		}
		else
			return SUCCESS;
	}
	else						//监控模式
	{
		//存在 空闲的 位置		
		return send_play(cli);
	}	
}

static int recv_options(struct client *cli)
{
	if(cli->status != OPTIONS)
		return ERROR;
	
	rtp_format *fmt = (rtp_format *)cli->recv_buf;
	memcpy(&cli->fmt, fmt, sizeof(rtp_format));
	return send_options(cli);	
}

static int send_login(struct client *cli, int code)
{
	cli->send_size = sizeof(struct request) + 1;
	cli->send_buf = (unsigned char *)malloc(cli->send_size);

	if(!cli->send_buf)
		return ERROR;

	struct request *req = (struct request *)cli->send_buf;
	
	req->code = code;
	cli->status = OPTIONS;
	set_request_head(cli->send_head, 0, LOGIN_MSG, cli->send_size);
	return send_request(cli);
}

static int recv_login(struct client *cli)
{
	int code;
   	int server_major = 0, server_minor = 0;
    int client_major = 0, client_minor = 0;
	
	get_version(&server_major, &server_minor);
	sscanf(cli->recv_buf, VERSIONFORMAT, &client_major, &client_minor);
	if(server_major == client_major && server_minor == client_minor)
	{
		code = 200;
	}
	else
	{
		code = 401;
		DEBUG("version server"VERSIONFORMAT" client"VERSIONFORMAT" error", server_major, server_minor, 
				client_major, client_minor);
	}
	return send_login(cli, code);
}

int process_server_msg(struct client *cli)
{
	int ret;
	DEBUG("read_msg_order(cli->recv_head) %d", read_msg_order(cli->recv_head));
	switch(read_msg_order(cli->recv_head))
	{
		/* pipe msg */
		case EXIT_PIPE:
			ret = EXIT_PIPE;
			break;
		case LOGIN_MSG:
			ret = recv_login(cli);
			break;
		case OPTIONS_MSG:
			ret = recv_options(cli);
			break;
		case PLAY_MSG:
			ret = recv_play(cli);
			break;
		case CONTROL_MSG:
			ret = recv_control(cli);
			break;
		case DONE_MSG:
			ret = recv_done(cli);
			break;
		default:
			break;	
	}
	ret = SUCCESS;
	return ret;
}

static void tcp_loop(int listenfd)
{
    int maxfd = 0, connfd, sockfd;
    int nready, ret, i, maxi = 0; 

    fd_set reset, allset;

    struct sockaddr_in cliaddr;
    socklen_t clilen = sizeof(cliaddr);
    
    struct timeval tv;
    tv.tv_sec = 1; 
    tv.tv_usec = 0; 
    
    FD_ZERO(&allset);
    FD_SET(listenfd, &allset);
    FD_SET(pipe_tcp[0], &allset);   

    maxfd = maxfd > listenfd ? maxfd : listenfd;
    maxfd = maxfd > pipe_tcp[0] ? maxfd : pipe_tcp[0];

	struct client pipe_cli = {0};
	clients[0] = &pipe_cli;	
	pipe_cli.fd = pipe_tcp[0];
	struct client *cli = NULL;
	time_t last_time = current_time;

	for(;;)
	{
        tv.tv_sec = 1;
        reset = allset;
        ret = select(maxfd + 1, &reset, NULL, NULL, &tv);
        if(ret == -1)
        {    
             if(errno == EINTR)
                continue; 
            else if(errno != EBADF)
            {   
                DEBUG("select %d %s ", errno, strerror(errno));
                return;
            }
        }
        nready = ret;

	   	(void)time(&current_time);
        if(current_time - last_time >= TIME_OUT)
        {   
            last_time = current_time;
        } 
	
        /* new connect */
        if(FD_ISSET(listenfd, &reset))
        {    
            connfd = accept(listenfd, (struct sockaddr*)&cliaddr, &clilen);
            if(connfd < 0) 
                continue;
            cli = (struct client *)malloc(sizeof(struct client));
            if(!cli)
            {    
                DEBUG("new connect and malloc struct client error :%s", strerror(errno));
                continue;
            }    
            memset(cli, 0, sizeof(struct client));
            cli->fd = connfd;
            cli->recv_size = HEAD_LEN;
#ifdef _WIN32
			ret = 1;
    		if(ioctlsocket(connfd, FIONBIO, (u_long *)&ret) == SOCKET_ERROR)
    		{   
        		DEBUG("fcntl F_SETFL fail");
    		} 
            memcpy(cli->ip,inet_ntoa(cliaddr.sin_addr), sizeof(cli->ip));
#else
            ret = fcntl(connfd, F_GETFL, 0);
            if(ret < 0) 
            {    
                DEBUG("fcntl connfd: %d  F_GETFL error :%s", connfd, strerror(errno));
                close_fd(connfd);
                free(cli);
                continue;
            }    

            if(fcntl(connfd, F_SETFL, ret | O_NONBLOCK) < 0) 
            {    
                DEBUG("fcntl connfd: %d F_SETFL O_NONBLOCK error :%s", connfd, strerror(errno));
                close_fd(connfd);
                free(cli);
                continue;
            }    
            /* recode client ip */
            if(inet_ntop(AF_INET, &cliaddr.sin_addr, cli->ip, sizeof(cli->ip)) == NULL)
            {    
                DEBUG("connfd: %d inet_ntop error ",connfd, strerror(errno));
                close_fd(connfd);
                free(cli);
                continue;
            }    
#endif
            FD_SET(connfd, &allset);
            for(i = 0; i < max_connections; i++)
            {
                if(clients[i] == NULL)
				{
                    clients[i] = cli;
                	break;
				}
            }
			cli->session_id = i;
            total_connections ++;
            if(i >= maxi)
                maxi = i;
            if(connfd > maxfd)
                maxfd = connfd;

            DEBUG("client index: %d total_connections: %d maxi: %d connfd ip: %s",i, total_connections, maxi, cli->ip);
            if(--nready <= 0)
                continue;
        }
    
		for(i = 0; i <= maxi; i++)
		{
            if(clients[i] == NULL || (sockfd = clients[i]->fd) < 0)    